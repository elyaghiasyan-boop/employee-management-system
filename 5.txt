"""
This script simulates renewable energy generation for developing countries,
performs statistical analysis, and saves results in CSV, TXT, and SQLite.
It demonstrates advanced Python features including:
- OOP (encapsulation, inheritance, polymorphism, composition)
- Random data simulation
- Functools utilities
- Collections usage
- Numpy & Pandas for statistical analysis
- File handling with CSV, TXT, Pathlib, and OS
- Logging, threading, subprocess, requests, JSON, SQLite
"""

import os
from pathlib import Path
import csv
import statistics
import random
import logging
import datetime
import threading
import time
import subprocess
import json
import re
import sqlite3
from itertools import accumulate, chain, cycle, count, product
from functools import lru_cache, partial, reduce, total_ordering, singledispatch, cmp_to_key
from collections import Counter, defaultdict, OrderedDict, deque, namedtuple, ChainMap
import numpy as np
import pandas as pd
import requests

# -----------------------
# LOGGING CONFIG
# -----------------------
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")

# -----------------------
# FILE SYSTEM SETUP
# -----------------------
BASE_DIR = Path.cwd() / "full_energy_analysis"
DATA_DIR = BASE_DIR / "data"
OUTPUT_DIR = BASE_DIR / "output"
DATA_DIR.mkdir(parents=True, exist_ok=True)
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

CSV_PATH = OUTPUT_DIR / "energy_generation.csv"
TXT_PATH = OUTPUT_DIR / "summary_report.txt"
DB_PATH = OUTPUT_DIR / "energy_data.sqlite"

# -----------------------
# RANDOM GENERATION FUNCTIONS
# -----------------------
random.seed(42)  # reproducibility

def climate_uncertainty():
    return random.gauss(1.0,0.15) * random.lognormvariate(0,0.25) * random.betavariate(2,5)/random.paretovariate(3)

def simulate_generation(base):
    return round(base * climate_uncertainty(),2)

# -----------------------
# OOP: ENERGY SOURCES
# -----------------------
@total_ordering
class EnergySource:
    def __init__(self, country, source, base_capacity):
        self.country = country
        self.source = source
        self._base_capacity = base_capacity
        self.generated = simulate_generation(base_capacity)
    
    def apply_policy(self, func):
        self.generated = round(self.generated * func(), 2)

    def __eq__(self, other):
        return self.generated == other.generated

    def __lt__(self, other):
        return self.generated < other.generated

    def __repr__(self):
        return f"{self.country}-{self.source}: {self.generated} TWh"

class AdvancedEnergy(EnergySource):
    def __init__(self, country, source, base_capacity, cost_per_mwh):
        super().__init__(country, source, base_capacity)
        self.cost_per_mwh = cost_per_mwh
    
    @lru_cache(maxsize=None)
    def learning_curve(self, cumulative_capacity):
        return round(self.cost_per_mwh * cumulative_capacity ** -0.2,2)

# -----------------------
# FUNCTOOLS
# -----------------------
def subsidy_effect(rate):
    return 1 + rate

india_policy = partial(subsidy_effect, 0.25)
kenya_policy = partial(subsidy_effect, 0.40)

def risk_adjustment(value):
    return value * random.uniform(0.9,1.1)

# -----------------------
# DATA GENERATION
# -----------------------
countries = ["India","Brazil","Kenya","Vietnam","Ethiopia"]
sources = ["Solar","Wind","Hydro"]
energy_objects = []

for country in countries:
    for source in sources:
        base = random.uniform(20,150)
        e = AdvancedEnergy(country, source, base, cost_per_mwh=random.uniform(30,80))
        if country=="India": e.apply_policy(india_policy)
        if country=="Kenya": e.apply_policy(kenya_policy)
        energy_objects.append(e)

# -----------------------
# COLLECTIONS
# -----------------------
EnergyRecord = namedtuple("EnergyRecord", ["country","source","generation"])
records = [EnergyRecord(e.country,e.source,e.generated) for e in energy_objects]

source_counter = Counter(r.source for r in records)

country_map = defaultdict(list)
for r in records: country_map[r.country].append(r.generation)

rolling_window = deque([r.generation for r in records], maxlen=5)
policy_chain = ChainMap({"subsidy":0.3},{"regional_tax":True},{"carbon_market":True})
policy_order = OrderedDict([("Solar",1),("Wind",2),("Hydro",3)])

# -----------------------
# STATISTICS & NUMPY
# -----------------------
all_gen = [r.generated for r in energy_objects]

stats_summary = {
    "mean": statistics.mean(all_gen),
    "median": statistics.median(all_gen),
    "variance": statistics.variance(all_gen),
    "stdev": statistics.stdev(all_gen),
    "min": min(all_gen),
    "max": max(all_gen)
}

np_array = np.array(all_gen)
numpy_summary = {
    "mean": np.mean(np_array),
    "std": np.std(np_array),
    "var": np.var(np_array),
    "percentiles": np.percentile(np_array,[25,50,75]).tolist()
}

# -----------------------
# PANDAS DATAFRAMES
# -----------------------
df = pd.DataFrame(records)
df_grouped = df.groupby(["country","source"]).agg(avg_generation=("generation","mean"),
                                                  total_generation=("generation","sum"))
df.to_csv(CSV_PATH,index=False)

# -----------------------
# TXT REPORT
# -----------------------
with open(TXT_PATH,"w") as f:
    f.write("FULL ENERGY ANALYSIS REPORT\n")
    f.write("="*50+"\n\n")
    f.write("STATISTICS:\n")
    for k,v in stats_summary.items(): f.write(f"{k}: {round(v,2)}\n")
    f.write("\nNUMPY SUMMARY:\n")
    for k,v in numpy_summary.items(): f.write(f"{k}: {v}\n")
    f.write("\nSOURCE COUNTER:\n")
    for k,v in source_counter.items(): f.write(f"{k}: {v}\n")
    f.write(f"\nROLLING AVERAGE (LAST 5): {round(statistics.mean(rolling_window),2)}\n")

# -----------------------
# SQLITE3 STORAGE
# -----------------------
conn = sqlite3.connect(DB_PATH)
cursor = conn.cursor()
cursor.execute("""CREATE TABLE IF NOT EXISTS energy(
                  country TEXT, source TEXT, generation REAL)""")
cursor.executemany("INSERT INTO energy VALUES (?,?,?)",
                   [(r.country,r.source,r.generation) for r in records])
conn.commit()
conn.close()

# -----------------------
# SUBPROCESS + REQUESTS EXAMPLE
# -----------------------
subprocess.run(["ls", "-l", str(OUTPUT_DIR)])

try:
    response = requests.get("https://api.sampleapis.com/futurama/characters")
    if response.status_code==200:
        data_json = response.json()
        with open(DATA_DIR/"api_data.json","w") as f:
            json.dump(data_json,f)
except Exception as e:
    logging.warning(f"Request failed: {e}")

# -----------------------
# FINAL SUMMARY
# -----------------------
total_energy = reduce(lambda acc,r: acc + r.generation,records,0)
print("\n--- ENERGY GENERATION TABLE ---\n",df_grouped)
print("\nTOTAL ENERGY GENERATED:",round(total_energy,2),"TWh")
print("\nCSV saved to:",CSV_PATH)
print("TXT report saved to:",TXT_PATH)
print("SQLite DB saved to:",DB_PATH)
